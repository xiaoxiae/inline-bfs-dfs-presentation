% notes to myself:
% - starred version (e.g. \section*{Section name}) disables the (sub)section page.

\documentclass[czech]{beamer}
\usepackage{babel}

% use the focus theme (without fira)
\usetheme[nofirafonts]{focus}
\usefonttheme{serif}

% shamelessly stolen from https://www.patrickbaylis.com/posts/2018-10-11-beamer-resizing/
\usepackage{adjustbox}
\makeatletter
\newcommand{\fitimage}[2][\@nil]{
	\begin{figure}
		\begin{adjustbox}{width=0.9\textwidth, totalheight=\textheight-2\baselineskip-2\baselineskip,keepaspectratio}
			\includegraphics{#2}
		\end{adjustbox}
		\def\tmp{#1}%
	 \ifx\tmp\@nnil
			\else
			\caption{#1}
		\fi
	\end{figure}
}
\makeatother

\setlength{\belowcaptionskip}{-5pt}

% bullets
\setbeamertemplate{itemize item}{$\bullet$}
\setbeamertemplate{itemize subitem}{$\bullet$}
\setbeamertemplate{itemize subsubitem}{$\bullet$}
\setbeamercolor{itemize subsubitem}{fg=main}

% code
\usepackage{minted}
\setminted[python]{
	linenos,
	mathescape=true,
	escapeinside=||,
	autogobble,
	obeytabs=true,
	tabsize=4}

% tables
\usepackage{booktabs}

% number lemmas and theorems
\setbeamertemplate{theorems}[numbered]

\makeatletter
\AtBeginEnvironment{proof}{\let\@addpunct\@gobble}
\makeatother

% translations
\newtranslation[to=Czech]{Definition}{Definice}


\title{In-place BFS a DFS}
\subtitle{v lineárním čase na modelu RAM}
\date{Tomáš Sláma \hfill 7. 4. 2020}

\begin{document}
	\begin{frame}
		\maketitle
	\end{frame}
	
	\section{Úvod}
	\begin{frame}{Předpoklady}
		\begin{itemize}
			\item pracujeme s modelem RAM
			\begin{itemize}
				\item paměť je pole slov velikosti $w$
				\item operace se slovy (čtení, psaní, přístupy) jsou konstantní
				\item vstup je na prvních $n \in \mathbb{N}$ slovech
				\item velikost $w = \Omega\left(\log n\right)$
			\end{itemize}
			\vfill
			\item vstup může být měněn v průběhu výpočtu, ale na jeho konci musí být v původním stavu
			\vfill
			\item graf je zadán v setříděném seznamu sousedů
		\end{itemize}

		\fitimage[setřízená reprezentace]{images/sorted.png}
	\end{frame}

	\section{DFS}

	\begin{frame}{Disclaimer}
		\begin{itemize}
			\item algoritmus všechny funkce podporovat nemůže
		\end{itemize}

		\begin{table}
			\centering
			\begin{tabular}{llc}
				\toprule
				\emph{operace} & \emph{význam} & \emph{podpora} \\
				\midrule
				\mintinline{python}{pre-process} & po vstoupení do vrcholu & $\checkmark$ \\
				\mintinline{python}{pre-explore} & po iteraci přes souseda &  \\
				\mintinline{python}{post-process} & po zpracovaní všech sousedů & $\checkmark$ \\
				\mintinline{python}{post-explore} & po vrácení z vrcholu &  \\
				\bottomrule
			\end{tabular}
			\caption{podporované funkce DFS}
		\end{table}
	\end{frame}

	\begin{frame}{Reprezentace}
		\fitimage{images/sorted.png}
		\fitimage{images/pointer.png}
		\fitimage[setřízená, pointerová a prohozená reprezentace]{images/swapped.png}
	\end{frame}

	\begin{frame}{setřízená $\rightarrow$ pointerová}
		\begin{lemma}
			Setříděná reprezentace jde do pointerové reprezentace převést in-place v čase $\mathcal{O}\left(n\right)$.
		\end{lemma}

		\begin{proof}
			Nastavíme $A[i] = T\left[A\left[i\right]\right] \forall i \in \left\{n + 2, \ldots, n + m + 2\right\}$ \\
			a $T\left[v\right] = v$ (pro vrcholy $v$ stupně $0$).
		\end{proof}
	\end{frame}

	\begin{frame}{pointerová $\longleftrightarrow$ prohozená}
		\begin{lemma}
			Pointerová jde do prohozené reprezentace (a zpět) převést in-place v čase $\mathcal{O}\left(n\right)$.
		\end{lemma}

		\begin{proof}
			Převod $\rightarrow$: $$T[i] = A[T[i]]\ \text{a}\ A[T[i]] = i\quad \forall i \in \left\{1, \ldots, n\right\}, i \neq T[i]$$
			Převod $\leftarrow$: $$T[A[i]] = i\ \text{a}\ T[A[i]] = i \quad \forall i \in \left\{n + 2, \ldots, n + m + 2\right\}, A[i] < n$$
		\end{proof}
	\end{frame}

	\begin{frame}{prohozená $\rightarrow$ setřízená}
		\begin{lemma}
			Prohozená jde do setřízené reprezentace převést in-place v čase $\mathcal{O}\left(n\right)$.
		\end{lemma}
	\end{frame}

	\begin{frame}{prohozená $\rightarrow$ setřízená}
		\begin{proof}[Důkaz?]
			\small
			Nejprve nastavíme 
			\begin{gather*}
				A[i] = A[A[i]]\ \forall i \in \left\{n + 2, \ldots, n + m + 2\right\}, A[i] > n \\
				\text{a} \\
				T[i] = A[T[i]]\ \forall i \in \left\{1, \ldots, n\right\}
			\end{gather*}

			Pak postupně hledáme jména vrcholů $v$ na pozicích $p$ v každém poli sousednosti a nastavujeme:
			$$A[p] = T[v]\ \text{a}\ T\left[v\right] = p$$

			Nakonec opravíme vrcholy stupně $0$ procházením $T$ a nastavením
			$$T[i] = T[i - 1]\ \forall i \in \left\{1, \ldots, n\right\}, T[i] = i$$
		\end{proof}
	\end{frame}

	\begin{frame}{prohozená $\rightarrow$ setřízená}
		\begin{proof}[Důkaz!]
			TODO
		\end{proof}
	\end{frame}

	\begin{frame}{Přehled}
		\begin{enumerate}
			\item graf převedeme ze setřízené do prohozené reprezentace
			\item budeme v ní ukládat aktuální stav DFS a trochu ji rozbijeme
			\item obnovíme její původní stav
			\item převedeme zpět do setřízené
		\end{enumerate}
	\end{frame}

	\subsection{Vrcholy se stupněm $\ge 2$}

	\begin{frame}{Zavedení invariantu}
		\begin{block}{Invariant}
			Vrchol $v$ je bílý $\iff A[T[v]] \le n$.
		\end{block}
		\begin{itemize}
			\item stav vrcholů budeme udržovat přes invariant
			\item na začátku platí pro všechny vrcholy
		\end{itemize}
		\vfill
		\fitimage[prohozená reprezentace]{images/swapped.png}
	\end{frame}

	\begin{frame}{Procházení přes obrácené pointery}
		\begin{itemize}
			\item jsme ve vrcholu $u$ a iterujeme přes jeho sousedy
			\item na pozici $p$ jsme narazili na pointer $q$ do bílého vrcholu $v$, jehož nejmenší soused je na pozici $q'$
			\item nastavíme $T[v] = p$ a $A[p] = q'$
		\end{itemize}
		\fitimage[diagram konstrukce obráceného pointeru]{images/deg2.png}
		\begin{itemize}
			\item pozorování: vrchol $v$ už není bílý
		\end{itemize}
	\end{frame}

	\begin{frame}{Problémy s obrácenými pointery}
		\begin{itemize}
			\item TODO
		\end{itemize}
	\end{frame}

	\begin{frame}{Backtrackování}
		\begin{itemize}
			\item po prozkoumání všech vrcholů $v$ narazíme na vrchol $v''$
			\item iterujeme zpět do té doby, dokud $A[q] > n$
		\end{itemize}

		\begin{figure}
			\centering
			\includegraphics{images/deg2-fix.png}
			\caption{diagram konstrukce obráceného pointeru}
		\end{figure}
		\begin{itemize}
			\item problém: vrchol $v$ už je zase bílý
			\begin{itemize}
				\item fix: $q' = q' + 1$ -- jelikož jsou stupně všech vrcholů $\ge 2$, tak po inkrementu $q'$ ukazuje na nějaký pointer
			\end{itemize}
		\end{itemize}
	\end{frame}

	\section{BFS}
	\begin{frame}{Přehled}
		\begin{enumerate}
			\item $T$ zkomprimujeme na $\mathcal{T}$ s tím, že:
			\begin{itemize}
				\item zachováme konstantní přístup
				\item uvolníme lineární počet bitů
			\end{itemize}
			\item uvolněné místo použijeme na datovou strukturu pro ukládání stavů vrcholů
			\item provedeme BFS
			\item $\mathcal{T}$ dekomprimujeme na $T$
		\end{enumerate}
	\end{frame}

	\begin{frame}{Color choice dictionary}
		\begin{itemize}
			\item zobecnění struktury choice dictionary
			\item udřuje $S_0, \ldots, S_{c - 1}$ podmnožin $\left\{1, \ldots, n\right\}$, kde:

				$$\bigcap_{i=0}^{c-1} S_i = \emptyset \qquad\bigcup_{i=0}^{c-1} S_i = \left\{1, \ldots, n\right\}$$

			\item vyžaduje řádově $nc$ bitů paměti
		\end{itemize}

		\vfill

		\begin{table}
			\centering
			\begin{tabular}{llc}
				\toprule
				operace & význam & složitost \\
				\midrule
				\mintinline{python}{setColor(v, c)} & nastaví barvu $v$ na $c$        & $\mathcal{O}\left(1\right)$ \\
				\mintinline{python}{getColor(v)}    & získá barvu $v$                 & $\mathcal{O}\left(1\right)$ \\
				\mintinline{python}{choice(c)}      & získá libovolný $v$ s barvu $c$ & $\mathcal{O}\left(1\right)$ \\
				\bottomrule
			\end{tabular}
			\caption{podporované operace CCD}
		\end{table}
	\end{frame}

	\begin{frame}{Komprimace $T$}
		\begin{itemize}
			\item potřebujeme uvolnit $nc$ bitů
				\vfill
			\item najdeme pozice, kde se mění $c + 1$ MSbitů ve slovech z $T$
			\begin{itemize}
				\item díky setříděnosti jich bude právě $2^{c - 1}$
				\item každé slovo o tolik bitů zkrátíme
				\item zapamatujeme si pozice změn v $T$
			\end{itemize}
				\vfill
			\item dohromady $nw - n(w - (c + 1)) = n(c + 1) = nc + n$
			\begin{itemize}
				\item omezení: $n \ge 2^{c + 1}w$, abychom mohli uložit pozice a $c + 1$
			\end{itemize}
		\end{itemize}

		\fitimage[komprimovaná reprezentace $\mathcal{T}$]{images/compression.png}
	\end{frame}

	\begin{frame}{Získávání hodnot z $\mathcal{T}$}
		\begin{enumerate}
			\item bitovými operacemi získáme $w - (c + 1)$ LSbitů slova
			\begin{itemize}
				\item $i$-té slovo v $\mathcal{T}$ začíná na pozici $(w - (c + 1))(i - 1)$
			\end{itemize}
			\item procházíme postupně $2^{c - 1}$ pozic, podle kterých zrekonstruujeme $c + 1$ MSbitů
		\end{enumerate}
	\end{frame}


	\begin{frame}[fragile]{Průběh BFS}
		\small
		\begin{minted}[xleftmargin=.08\textwidth]{python}
			D = ColorChoiceDictionary(WHITE, LIGHT, DARK, BLACK)
			D.setColor(start, LIGHT)

			while choice(LIGHT) is not None:
				while choice(LIGHT) is not None:
					v = D.choice(LIGHT)  # pop node

					# open all white neighbours
					for i in range(|$\mathcal{T}[v]$|, |$\mathcal{T}[v + 1]$|):
						if D.getColor(|$A[i]$|) is WHITE:
							D.setColor(|$A[i]$|, DARK)

					D.setColor(v, BLACK)  # close the node

				LIGHT, DARK = DARK, LIGHT  # next round
		\end{minted}
	\end{frame}

	\begin{frame}[focus]
		Díky za pozornost!
	\end{frame}
	
	\appendix
	\begin{frame}{Zdroje a dodatečné materiály}
		\nocite{*}
		\bibliography{presentation}
		\bibliographystyle{plain}
	\end{frame}
\end{document}
